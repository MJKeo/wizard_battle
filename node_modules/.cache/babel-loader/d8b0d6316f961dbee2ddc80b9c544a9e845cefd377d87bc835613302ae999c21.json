{"ast":null,"code":"import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(new Player(index, wizard), max_hp, max_hp, wizard.starting_mana(randomFn), []);\n    });\n    this.action_log = [];\n    return this.player_states.map(state => state.player.wizard);\n  }\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, state.current_mana + delta);\n    return state.current_mana;\n  }\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, value);\n    return state.current_mana;\n  }\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter(effect => effect.remaining_turns > 0);\n  }\n  tick_effects() {\n    this.player_states.forEach(state => {\n      state.active_effects.forEach(effect => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n  log_action(record) {\n    this.action_log.push(record);\n  }\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    if (action.mana_cost() > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n    const result = action.perform_action(randomFn);\n    if (!(result !== null && result !== void 0 && result.succeeded)) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - action.mana_cost());\n    let final_action_value = result.value;\n    switch (result.action_type) {\n      case ActionType.HEAL:\n        {\n          const healed = this._apply_heal(actor_state, Number(result.value));\n          final_action_value = healed;\n          this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n          break;\n        }\n      case ActionType.DEFEND:\n        {\n          this._apply_status(actor_state, new StatusEffect(action.element.name, StatusEffectType.DEFENSE, 0.0, 3));\n          this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n          break;\n        }\n      case ActionType.CAST_SPELL:\n        {\n          switch (result.spell_type) {\n            case SpellType.DAMAGE:\n              {\n                const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n                this._apply_damage(defender_state, damage);\n                final_action_value = damage;\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n                break;\n              }\n            case SpellType.BUFF:\n              {\n                this._apply_status(actor_state, new StatusEffect(action.name, StatusEffectType.BUFF, Number(result.value), 4));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n                break;\n              }\n            case SpellType.DEBUFF:\n              {\n                this._apply_status(defender_state, new StatusEffect(action.name, StatusEffectType.DEBUFF, Number(result.value), 3));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n                break;\n              }\n            default:\n              throw new Error(`Unhandled spell type: ${result.spell_type}`);\n          }\n          break;\n        }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type}`);\n    }\n    this._decay_effects(actor_index);\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach(effect => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach(buff => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach(debuff => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach(buff => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach(debuff => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n    defender.defenses().forEach(defense => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n    return Math.max(0, Math.round(damage));\n  }\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n  increment_mana() {\n    this.player_states.forEach(state => {\n      state.current_mana += state.player.wizard.mana_per_round();\n    });\n  }\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n    return lines.join(\"\\n\");\n  }\n  battleSnapshot(actingWizardIndex) {\n    var _actingState$active_e, _enemyState$active_ef;\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n    const formatActions = actions => {\n      if (!(actions !== null && actions !== void 0 && actions.length)) {\n        return \"  (none)\";\n      }\n      return actions.map((action, idx) => {\n        const overview = action.overview();\n        return `${idx + 1}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n      }).join(\"\\n\");\n    };\n    const actingActions = formatActions(actingState.player.wizard.affordable_actions(actingState.current_mana));\n    const enemyActions = formatActions(enemyState.player.wizard.affordable_actions(enemyState.current_mana));\n    const actingEffects = (_actingState$active_e = actingState.active_effects) !== null && _actingState$active_e !== void 0 && _actingState$active_e.length ? actingState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    const enemyEffects = (_enemyState$active_ef = enemyState.active_effects) !== null && _enemyState$active_ef !== void 0 && _enemyState$active_ef.length ? enemyState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\nconst game_state = new GameState();\nexport { GameState };\nexport default game_state;","map":{"version":3,"names":["ActionType","ActionTarget","SpellType","StatusEffectType","EffectGroup","Player","PlayerState","StatusEffect","ActionRecord","shuffle","array","randomFn","Math","random","copy","i","length","j","floor","GameState","constructor","player_states","action_log","initialize","wizard1","wizard2","assigned_order","map","wizard","index","max_hp","starting_mana","state","player","change_health","delta","id","current_health","max","min","max_health","set_health","value","change_mana","current_mana","set_mana","add_status_effect","effect","existing","active_effects","find","active","name","remaining_turns","effect_type","push","clear_expired_effects","filter","tick_effects","forEach","log_action","record","perform_action","actor_index","action","Error","actor_state","defender_state","mana_cost","result","succeeded","action_type","action_target","_decay_effects","failure_announcement","final_action_value","HEAL","healed","_apply_heal","Number","SELF","DEFEND","_apply_status","element","DEFENSE","CAST_SPELL","spell_type","DAMAGE","damage","_calculate_damage","_apply_damage","ENEMY","BUFF","DEBUFF","success_announcement","get_winner","_decrement_effects","BUFFS_AND_DEBUFFS","DEFENSES","group","updated","includes","amount","new_health","actor","defender","spell","base_damage","actor_multiplier","damage_multiplier","buffs","buff","debuffs","debuff","defender_multiplier","damage_reduction","defenses","defense","defense_element","strengths","weaknesses","round","increment_mana","mana_per_round","toString","lines","idx","actor_label","actor_id","type","target","join","battleSnapshot","actingWizardIndex","_actingState$active_e","_enemyState$active_ef","actingState","enemyState","formatActions","actions","overview","Array","isArray","actingActions","affordable_actions","enemyActions","actingEffects","enemyEffects","combat_style","game_state"],"sources":["/Users/michaelkeohane/Documents/Projects/LLM-Learnings/projects/week_2/wizard_prompt_battle/wizard-battle-client/src/classes/gameState.js"],"sourcesContent":["import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\n\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\n\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(\n        new Player(index, wizard),\n        max_hp,\n        max_hp,\n        wizard.starting_mana(randomFn),\n        []\n      );\n    });\n\n    this.action_log = [];\n    return this.player_states.map((state) => state.player.wizard);\n  }\n\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, state.current_mana + delta);\n    return state.current_mana;\n  }\n\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, value);\n    return state.current_mana;\n  }\n\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter((effect) => effect.remaining_turns > 0);\n  }\n\n  tick_effects() {\n    this.player_states.forEach((state) => {\n      state.active_effects.forEach((effect) => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n\n  log_action(record) {\n    this.action_log.push(record);\n  }\n\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    if (action.mana_cost() > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n\n    const result = action.perform_action(randomFn);\n\n    if (!result?.succeeded) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - action.mana_cost());\n    let final_action_value = result.value;\n\n    switch (result.action_type) {\n      case ActionType.HEAL: {\n        const healed = this._apply_heal(actor_state, Number(result.value));\n        final_action_value = healed;\n        this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n        break;\n      }\n      case ActionType.DEFEND: {\n        this._apply_status(\n          actor_state,\n          new StatusEffect(\n            action.element.name,\n            StatusEffectType.DEFENSE,\n            0.0,\n            3\n          )\n        );\n        this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n        break;\n      }\n      case ActionType.CAST_SPELL: {\n        switch (result.spell_type) {\n          case SpellType.DAMAGE: {\n            const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n            this._apply_damage(defender_state, damage);\n            final_action_value = damage;\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n            break;\n          }\n          case SpellType.BUFF: {\n            this._apply_status(\n              actor_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.BUFF,\n                Number(result.value),\n                4\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n            break;\n          }\n          case SpellType.DEBUFF: {\n            this._apply_status(\n              defender_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.DEBUFF,\n                Number(result.value),\n                3\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n            break;\n          }\n          default:\n            throw new Error(`Unhandled spell type: ${result.spell_type}`);\n        }\n        break;\n      }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type}`);\n    }\n\n    this._decay_effects(actor_index);\n\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach((effect) => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach((buff) => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach((debuff) => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach((buff) => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach((debuff) => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n\n    defender.defenses().forEach((defense) => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n\n    return Math.max(0, Math.round(damage));\n  }\n\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n\n  increment_mana() {\n    this.player_states.forEach((state) => {\n      state.current_mana += state.player.wizard.mana_per_round();\n    });\n  }\n\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  battleSnapshot(actingWizardIndex) {\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n\n    const formatActions = (actions) => {\n      if (!actions?.length) {\n        return \"  (none)\";\n      }\n      return actions\n        .map((action, idx) => {\n          const overview = action.overview();\n          return `${idx + 1}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n        })\n        .join(\"\\n\");\n    };\n\n    const actingActions = formatActions(\n      actingState.player.wizard.affordable_actions(actingState.current_mana)\n    );\n    const enemyActions = formatActions(\n      enemyState.player.wizard.affordable_actions(enemyState.current_mana)\n    );\n\n    const actingEffects = actingState.active_effects?.length\n      ? actingState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n    const enemyEffects = enemyState.active_effects?.length\n      ? enemyState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\n\nconst game_state = new GameState();\n\nexport { GameState };\nexport default game_state;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}