{"ast":null,"code":"import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nimport Element from \"../enums/element\";\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(new Player(index, wizard), max_hp, max_hp, wizard.starting_mana(randomFn), []);\n    });\n    this.action_log = [];\n    return this.player_states.map(state => state.player.wizard);\n  }\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, state.current_mana + delta));\n    return state.current_mana;\n  }\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, value));\n    return state.current_mana;\n  }\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter(effect => effect.remaining_turns > 0);\n  }\n  tick_effects() {\n    this.player_states.forEach(state => {\n      state.active_effects.forEach(effect => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n  log_action(record) {\n    this.action_log.push(record);\n  }\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    const mana_cost = action.mana_cost();\n    if (mana_cost > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - mana_cost);\n    const result = action.perform_action(randomFn);\n    if (!(result !== null && result !== void 0 && result.succeeded)) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n    let final_action_value = result.value;\n    switch (result.action_type) {\n      case ActionType.HEAL:\n        {\n          const healed = this._apply_heal(actor_state, Number(result.value));\n          final_action_value = healed;\n          this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n          break;\n        }\n      case ActionType.DEFEND:\n        {\n          this._apply_status(actor_state, new StatusEffect(action.element.name, StatusEffectType.DEFENSE, 0.0, 3));\n          this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n          break;\n        }\n      case ActionType.CAST_SPELL:\n        {\n          switch (result.spell_type) {\n            case SpellType.DAMAGE:\n              {\n                const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n                this._apply_damage(defender_state, damage);\n                final_action_value = damage;\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n                break;\n              }\n            case SpellType.BUFF:\n              {\n                this._apply_status(actor_state, new StatusEffect(action.name, StatusEffectType.BUFF, Number(result.value), 4));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n                break;\n              }\n            case SpellType.DEBUFF:\n              {\n                this._apply_status(defender_state, new StatusEffect(action.name, StatusEffectType.DEBUFF, Number(result.value), 3));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n                break;\n              }\n            default:\n              throw new Error(`Unhandled spell type: ${result.spell_type}`);\n          }\n          break;\n        }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type}`);\n    }\n    this._decay_effects(actor_index);\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach(effect => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach(buff => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach(debuff => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach(buff => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach(debuff => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n    defender.defenses().forEach(defense => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n    return Math.max(0, Math.round(damage));\n  }\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n  increment_mana() {\n    this.player_states.forEach(state => {\n      state.current_mana = Math.max(0, Math.min(25, state.current_mana + state.player.wizard.mana_per_round()));\n    });\n  }\n  action_effect_range(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_effect_range requires an action instance\");\n    }\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      if (typeof action.range !== \"function\") {\n        return [0, 0];\n      }\n      const [minVal, maxVal] = action.range();\n      const minDamage = this._calculate_damage(actorState, defenderState, action, Number(minVal));\n      const maxDamage = this._calculate_damage(actorState, defenderState, action, Number(maxVal));\n      return [Math.round(minDamage), Math.round(maxDamage)];\n    }\n    if (typeof action.range === \"function\") {\n      return action.range();\n    }\n    return [0, 0];\n  }\n  action_is_redundant(actorIndex, action) {\n    var _actorState$active_ef, _enemyState$active_ef;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_is_redundant requires an action instance\");\n    }\n    const actorState = this.player_states[actorIndex];\n    const activeEffects = (_actorState$active_ef = actorState.active_effects) !== null && _actorState$active_ef !== void 0 ? _actorState$active_ef : [];\n    const enemyState = this.player_states[1 - actorIndex];\n    const enemyEffects = (_enemyState$active_ef = enemyState.active_effects) !== null && _enemyState$active_ef !== void 0 ? _enemyState$active_ef : [];\n    const actionType = action.action_type;\n    if (actionType === ActionType.DEFEND) {\n      var _action$element$name, _action$element, _ref, _existing$remaining_t;\n      const effectName = (_action$element$name = (_action$element = action.element) === null || _action$element === void 0 ? void 0 : _action$element.name) !== null && _action$element$name !== void 0 ? _action$element$name : action.element;\n      if (!effectName) {\n        return false;\n      }\n      const existing = activeEffects.find(effect => (effect.effect_type === StatusEffectType.DEFENSE || effect.is_defense) && String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n      if (!existing) {\n        return false;\n      }\n      const turns = (_ref = (_existing$remaining_t = existing.remaining_turns) !== null && _existing$remaining_t !== void 0 ? _existing$remaining_t : existing.rounds_remaining) !== null && _ref !== void 0 ? _ref : 0;\n      return turns >= 2;\n    }\n    if (actionType === ActionType.CAST_SPELL && typeof action.spell_type === \"function\") {\n      const spellType = action.spell_type();\n      if (spellType === SpellType.BUFF) {\n        var _ref2, _existing$remaining_t2;\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n        const existing = activeEffects.find(effect => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n        const turns = (_ref2 = (_existing$remaining_t2 = existing.remaining_turns) !== null && _existing$remaining_t2 !== void 0 ? _existing$remaining_t2 : existing.rounds_remaining) !== null && _ref2 !== void 0 ? _ref2 : 0;\n        return turns >= 2;\n      } else if (spellType === SpellType.DEBUFF) {\n        var _ref3, _existing$remaining_t3;\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n        const existing = enemyEffects.find(effect => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n        const turns = (_ref3 = (_existing$remaining_t3 = existing.remaining_turns) !== null && _existing$remaining_t3 !== void 0 ? _existing$remaining_t3 : existing.rounds_remaining) !== null && _ref3 !== void 0 ? _ref3 : 0;\n        return turns >= 2;\n      }\n    }\n    return false;\n  }\n  action_can_kill(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_can_kill requires an action instance\");\n    }\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      const [, maxDamage] = this.action_effect_range(actorIndex, action);\n      const defenderState = this.player_states[1 - actorIndex];\n      return maxDamage >= defenderState.current_health;\n    }\n    return false;\n  }\n  player_danger_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const enemyWizard = enemyState.player.wizard;\n    const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n    const canEnemyOneShot = enemyActions.some(action => {\n      if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n        const rangeFn = typeof action.range === \"function\" ? action.range : null;\n        const [, maxVal = 0] = rangeFn ? rangeFn.call(action) : [0, 0];\n        const damage = this._calculate_damage(enemyState, playerState, action, Number(maxVal));\n        return damage >= playerState.current_health;\n      }\n      return false;\n    });\n    if (canEnemyOneShot) {\n      return \"High\";\n    }\n    if (playerState.current_health <= playerState.max_health / 2) {\n      return \"Medium\";\n    }\n    return \"Low\";\n  }\n  action_element_effectiveness(actorIndex, action) {\n    var _defenderState$active, _defenderState$active2;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_element_effectiveness requires an action instance\");\n    }\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    const defenderWizard = defenderState.player.wizard;\n    const getElement = elementLike => {\n      if (!elementLike) {\n        return null;\n      }\n      if (typeof elementLike.name === \"string\") {\n        return Element.fromName(elementLike.name);\n      }\n      if (typeof elementLike === \"string\") {\n        return Element.fromName(elementLike);\n      }\n      return null;\n    };\n    const defenseEffects = (_defenderState$active = (_defenderState$active2 = defenderState.active_effects) === null || _defenderState$active2 === void 0 ? void 0 : _defenderState$active2.filter(effect => {\n      var _effect$effect_type;\n      return ((_effect$effect_type = effect.effect_type) !== null && _effect$effect_type !== void 0 ? _effect$effect_type : effect.type) === StatusEffectType.DEFENSE || effect.is_defense;\n    })) !== null && _defenderState$active !== void 0 ? _defenderState$active : [];\n    const defenseElements = defenseEffects.map(effect => {\n      var _effect$name;\n      return getElement((_effect$name = effect.name) !== null && _effect$name !== void 0 ? _effect$name : effect.element);\n    }).filter(Boolean);\n    if (typeof action.action_type !== \"undefined\") {\n      const actionType = action.action_type;\n      if (actionType === ActionType.CAST_SPELL && typeof action.spell_type === \"function\") {\n        const spellType = action.spell_type();\n        if (spellType === SpellType.DAMAGE) {\n          const actionElement = getElement(action.element);\n          if (!actionElement) {\n            return \"medium\";\n          }\n          if (!defenseElements.length) {\n            return \"high\";\n          }\n          const hasWeakDefense = defenseElements.some(defenseElement => defenseElement.strengths.includes(actionElement.name));\n          if (hasWeakDefense) {\n            return \"low\";\n          }\n          const allNeutral = defenseElements.every(defenseElement => !defenseElement.weaknesses.includes(actionElement.name) && !defenseElement.strengths.includes(actionElement.name));\n          if (allNeutral) {\n            return \"medium\";\n          }\n          const allVulnerable = defenseElements.every(defenseElement => defenseElement.weaknesses.includes(actionElement.name));\n          if (allVulnerable) {\n            return \"high\";\n          }\n          return \"medium\";\n        }\n      }\n      if (actionType === ActionType.DEFEND) {\n        var _defenderWizard$prima, _defenderWizard$secon;\n        const actionElement = getElement(action.element);\n        if (!actionElement) {\n          return \"medium\";\n        }\n        const enemyElements = [(_defenderWizard$prima = defenderWizard.primary_element) === null || _defenderWizard$prima === void 0 ? void 0 : _defenderWizard$prima.name, (_defenderWizard$secon = defenderWizard.secondary_element) === null || _defenderWizard$secon === void 0 ? void 0 : _defenderWizard$secon.name].filter(Boolean);\n        const isStrong = enemyElements.some(enemyElement => actionElement.strengths.includes(enemyElement));\n        const isWeak = enemyElements.some(enemyElement => actionElement.weaknesses.includes(enemyElement));\n        if (isStrong && isWeak) {\n          return \"medium\";\n        } else if (isStrong) {\n          return \"high\";\n        } else if (isWeak) {\n          return \"low\";\n        }\n        return \"medium\";\n      }\n    }\n    return \"medium\";\n  }\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n    return lines.join(\"\\n\");\n  }\n  battleSnapshot(actingWizardIndex) {\n    var _actingState$active_e, _enemyState$active_ef2;\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n    const formatActions = (actions, use_numbers = false) => {\n      if (!(actions !== null && actions !== void 0 && actions.length)) {\n        return \"  (none)\";\n      }\n      return actions.map((action, idx) => {\n        const overview = action.overview();\n        return `${use_numbers ? idx + 1 : \"\"}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n      }).join(\"\\n\");\n    };\n    const actingActions = formatActions(actingState.player.wizard.affordable_actions(actingState.current_mana), true);\n    const enemyActions = formatActions(enemyState.player.wizard.affordable_actions(enemyState.current_mana));\n    const actingEffects = (_actingState$active_e = actingState.active_effects) !== null && _actingState$active_e !== void 0 && _actingState$active_e.length ? actingState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    const enemyEffects = (_enemyState$active_ef2 = enemyState.active_effects) !== null && _enemyState$active_ef2 !== void 0 && _enemyState$active_ef2.length ? enemyState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\nconst game_state = new GameState();\nexport { GameState };\nexport default game_state;","map":{"version":3,"names":["ActionType","ActionTarget","SpellType","StatusEffectType","EffectGroup","Player","PlayerState","StatusEffect","ActionRecord","Element","shuffle","array","randomFn","Math","random","copy","i","length","j","floor","GameState","constructor","player_states","action_log","initialize","wizard1","wizard2","assigned_order","map","wizard","index","max_hp","starting_mana","state","player","change_health","delta","id","current_health","max","min","max_health","set_health","value","change_mana","current_mana","set_mana","add_status_effect","effect","existing","active_effects","find","active","name","remaining_turns","effect_type","push","clear_expired_effects","filter","tick_effects","forEach","log_action","record","perform_action","actor_index","action","Error","actor_state","defender_state","mana_cost","result","succeeded","action_type","action_target","_decay_effects","failure_announcement","final_action_value","HEAL","healed","_apply_heal","Number","SELF","DEFEND","_apply_status","element","DEFENSE","CAST_SPELL","spell_type","DAMAGE","damage","_calculate_damage","_apply_damage","ENEMY","BUFF","DEBUFF","success_announcement","get_winner","_decrement_effects","BUFFS_AND_DEBUFFS","DEFENSES","group","updated","includes","amount","new_health","actor","defender","spell","base_damage","actor_multiplier","damage_multiplier","buffs","buff","debuffs","debuff","defender_multiplier","damage_reduction","defenses","defense","defense_element","strengths","weaknesses","round","increment_mana","mana_per_round","action_effect_range","actorIndex","actorState","defenderState","range","minVal","maxVal","minDamage","maxDamage","action_is_redundant","_actorState$active_ef","_enemyState$active_ef","activeEffects","enemyState","enemyEffects","actionType","_action$element$name","_action$element","_ref","_existing$remaining_t","effectName","is_defense","String","toUpperCase","turns","rounds_remaining","spellType","_ref2","_existing$remaining_t2","_ref3","_existing$remaining_t3","action_can_kill","player_danger_level","playerIndex","playerState","enemyWizard","enemyActions","all_actions","canEnemyOneShot","some","rangeFn","call","action_element_effectiveness","_defenderState$active","_defenderState$active2","defenderWizard","getElement","elementLike","fromName","defenseEffects","_effect$effect_type","type","defenseElements","_effect$name","Boolean","actionElement","hasWeakDefense","defenseElement","allNeutral","every","allVulnerable","_defenderWizard$prima","_defenderWizard$secon","enemyElements","primary_element","secondary_element","isStrong","enemyElement","isWeak","toString","lines","idx","actor_label","actor_id","target","join","battleSnapshot","actingWizardIndex","_actingState$active_e","_enemyState$active_ef2","actingState","formatActions","actions","use_numbers","overview","Array","isArray","actingActions","affordable_actions","actingEffects","combat_style","game_state"],"sources":["/Users/michaelkeohane/Documents/Projects/LLM-Learnings/projects/week_2/wizard_prompt_battle/wizard-battle-client/src/classes/gameState.js"],"sourcesContent":["import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nimport Element from \"../enums/element\";\n\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\n\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(\n        new Player(index, wizard),\n        max_hp,\n        max_hp,\n        wizard.starting_mana(randomFn),\n        []\n      );\n    });\n\n    this.action_log = [];\n    return this.player_states.map((state) => state.player.wizard);\n  }\n\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, state.current_mana + delta));\n    return state.current_mana;\n  }\n\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, value));\n    return state.current_mana;\n  }\n\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter((effect) => effect.remaining_turns > 0);\n  }\n\n  tick_effects() {\n    this.player_states.forEach((state) => {\n      state.active_effects.forEach((effect) => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n\n  log_action(record) {\n    this.action_log.push(record);\n  }\n\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    const mana_cost = action.mana_cost();\n\n    if (mana_cost > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - mana_cost);\n\n    const result = action.perform_action(randomFn);\n\n    if (!result?.succeeded) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n\n    let final_action_value = result.value;\n\n    switch (result.action_type) {\n      case ActionType.HEAL: {\n        const healed = this._apply_heal(actor_state, Number(result.value));\n        final_action_value = healed;\n        this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n        break;\n      }\n      case ActionType.DEFEND: {\n        this._apply_status(\n          actor_state,\n          new StatusEffect(\n            action.element.name,\n            StatusEffectType.DEFENSE,\n            0.0,\n            3\n          )\n        );\n        this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n        break;\n      }\n      case ActionType.CAST_SPELL: {\n        switch (result.spell_type) {\n          case SpellType.DAMAGE: {\n            const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n            this._apply_damage(defender_state, damage);\n            final_action_value = damage;\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n            break;\n          }\n          case SpellType.BUFF: {\n            this._apply_status(\n              actor_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.BUFF,\n                Number(result.value),\n                4\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n            break;\n          }\n          case SpellType.DEBUFF: {\n            this._apply_status(\n              defender_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.DEBUFF,\n                Number(result.value),\n                3\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n            break;\n          }\n          default:\n            throw new Error(`Unhandled spell type: ${result.spell_type}`);\n        }\n        break;\n      }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type}`);\n    }\n\n    this._decay_effects(actor_index);\n\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach((effect) => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach((buff) => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach((debuff) => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach((buff) => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach((debuff) => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n\n    defender.defenses().forEach((defense) => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n\n    return Math.max(0, Math.round(damage));\n  }\n\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n\n  increment_mana() {\n    this.player_states.forEach((state) => {\n      state.current_mana = Math.max(\n        0,\n        Math.min(25, state.current_mana + state.player.wizard.mana_per_round())\n      );\n    });\n  }\n\n  action_effect_range(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_effect_range requires an action instance\");\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      if (typeof action.range !== \"function\") {\n        return [0, 0];\n      }\n      const [minVal, maxVal] = action.range();\n      const minDamage = this._calculate_damage(actorState, defenderState, action, Number(minVal));\n      const maxDamage = this._calculate_damage(actorState, defenderState, action, Number(maxVal));\n      return [Math.round(minDamage), Math.round(maxDamage)];\n    }\n\n    if (typeof action.range === \"function\") {\n      return action.range();\n    }\n\n    return [0, 0];\n  }\n\n  action_is_redundant(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_is_redundant requires an action instance\");\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const activeEffects = actorState.active_effects ?? [];\n    const enemyState = this.player_states[1 - actorIndex];\n    const enemyEffects = enemyState.active_effects ?? [];\n\n    const actionType = action.action_type;\n\n    if (actionType === ActionType.DEFEND) {\n      const effectName = action.element?.name ?? action.element;\n      if (!effectName) {\n        return false;\n      }\n\n      const existing = activeEffects.find(\n        (effect) =>\n          (effect.effect_type === StatusEffectType.DEFENSE || effect.is_defense) &&\n          String(effect.name).toUpperCase() === String(effectName).toUpperCase()\n      );\n\n      if (!existing) {\n        return false;\n      }\n\n      const turns = existing.remaining_turns ?? existing.rounds_remaining ?? 0;\n      return turns >= 2;\n    }\n\n    if (actionType === ActionType.CAST_SPELL && typeof action.spell_type === \"function\") {\n      const spellType = action.spell_type();\n      if (spellType === SpellType.BUFF) {\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n\n        const existing = activeEffects.find((effect) => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n\n        const turns = existing.remaining_turns ?? existing.rounds_remaining ?? 0;\n        return turns >= 2;\n      } else if (spellType === SpellType.DEBUFF) {\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n\n        const existing = enemyEffects.find((effect) => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n\n        const turns = existing.remaining_turns ?? existing.rounds_remaining ?? 0;\n        return turns >= 2;\n      }\n    }\n\n    return false;\n  }\n\n  action_can_kill(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_can_kill requires an action instance\");\n    }\n\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      const [, maxDamage] = this.action_effect_range(actorIndex, action);\n      const defenderState = this.player_states[1 - actorIndex];\n      return maxDamage >= defenderState.current_health;\n    }\n\n    return false;\n  }\n\n  player_danger_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const enemyWizard = enemyState.player.wizard;\n\n    const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n\n    const canEnemyOneShot = enemyActions.some((action) => {\n      if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n        const rangeFn = typeof action.range === \"function\" ? action.range : null;\n        const [, maxVal = 0] = rangeFn ? rangeFn.call(action) : [0, 0];\n        const damage = this._calculate_damage(enemyState, playerState, action, Number(maxVal));\n        return damage >= playerState.current_health;\n      }\n      return false;\n    });\n\n    if (canEnemyOneShot) {\n      return \"High\";\n    }\n\n    if (playerState.current_health <= playerState.max_health / 2) {\n      return \"Medium\";\n    }\n\n    return \"Low\";\n  }\n\n  action_element_effectiveness(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_element_effectiveness requires an action instance\");\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    const defenderWizard = defenderState.player.wizard;\n\n    const getElement = (elementLike) => {\n      if (!elementLike) {\n        return null;\n      }\n      if (typeof elementLike.name === \"string\") {\n        return Element.fromName(elementLike.name);\n      }\n      if (typeof elementLike === \"string\") {\n        return Element.fromName(elementLike);\n      }\n      return null;\n    };\n\n    const defenseEffects = defenderState.active_effects?.filter((effect) =>\n      (effect.effect_type ?? effect.type) === StatusEffectType.DEFENSE || effect.is_defense\n    ) ?? [];\n    const defenseElements = defenseEffects\n      .map((effect) => getElement(effect.name ?? effect.element))\n      .filter(Boolean);\n\n    if (typeof action.action_type !== \"undefined\") {\n      const actionType = action.action_type;\n\n      if (actionType === ActionType.CAST_SPELL && typeof action.spell_type === \"function\") {\n        const spellType = action.spell_type();\n        if (spellType === SpellType.DAMAGE) {\n          const actionElement = getElement(action.element);\n\n          if (!actionElement) {\n            return \"medium\";\n          }\n\n          if (!defenseElements.length) {\n            return \"high\";\n          }\n\n          const hasWeakDefense = defenseElements.some((defenseElement) =>\n            defenseElement.strengths.includes(actionElement.name)\n          );\n          if (hasWeakDefense) {\n            return \"low\";\n          }\n\n          const allNeutral = defenseElements.every((defenseElement) =>\n            !defenseElement.weaknesses.includes(actionElement.name) &&\n            !defenseElement.strengths.includes(actionElement.name)\n          );\n          if (allNeutral) {\n            return \"medium\";\n          }\n\n          const allVulnerable = defenseElements.every((defenseElement) =>\n            defenseElement.weaknesses.includes(actionElement.name)\n          );\n          if (allVulnerable) {\n            return \"high\";\n          }\n\n          return \"medium\";\n        }\n      }\n\n      if (actionType === ActionType.DEFEND) {\n        const actionElement = getElement(action.element);\n        if (!actionElement) {\n          return \"medium\";\n        }\n\n        const enemyElements = [defenderWizard.primary_element?.name, defenderWizard.secondary_element?.name].filter(Boolean);\n        const isStrong = enemyElements.some((enemyElement) => actionElement.strengths.includes(enemyElement));\n        const isWeak = enemyElements.some((enemyElement) => actionElement.weaknesses.includes(enemyElement));\n\n        if (isStrong && isWeak) {\n          return \"medium\";\n        } else if (isStrong) {\n          return \"high\";\n        } else if (isWeak) {\n          return \"low\";\n        }\n        return \"medium\";\n      }\n    }\n\n    return \"medium\";\n  }\n\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  battleSnapshot(actingWizardIndex) {\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n\n    const formatActions = (actions, use_numbers = false) => {\n      if (!actions?.length) {\n        return \"  (none)\";\n      }\n      return actions\n        .map((action, idx) => {\n          const overview = action.overview();\n          return `${use_numbers ? idx + 1 : \"\"}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n        })\n        .join(\"\\n\");\n    };\n\n    const actingActions = formatActions(\n      actingState.player.wizard.affordable_actions(actingState.current_mana), true\n    );\n    const enemyActions = formatActions(\n      enemyState.player.wizard.affordable_actions(enemyState.current_mana)\n    );\n\n    const actingEffects = actingState.active_effects?.length\n      ? actingState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n    const enemyEffects = enemyState.active_effects?.length\n      ? enemyState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\n\nconst game_state = new GameState();\n\nexport { GameState };\nexport default game_state;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}