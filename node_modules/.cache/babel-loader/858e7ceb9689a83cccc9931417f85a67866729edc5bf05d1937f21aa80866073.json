{"ast":null,"code":"import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nimport Element from \"../enums/element\";\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(new Player(index, wizard), max_hp, max_hp, wizard.starting_mana(randomFn), []);\n    });\n    this.action_log = [];\n    return this.player_states.map(state => state.player.wizard);\n  }\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, state.current_mana + delta));\n    return state.current_mana;\n  }\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, value));\n    return state.current_mana;\n  }\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter(effect => effect.remaining_turns > 0);\n  }\n  tick_effects() {\n    this.player_states.forEach(state => {\n      state.active_effects.forEach(effect => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n  log_action(record) {\n    this.action_log.push(record);\n  }\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    const mana_cost = action.mana_cost();\n    if (mana_cost > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - mana_cost);\n    const result = action.perform_action(randomFn);\n    if (!(result !== null && result !== void 0 && result.succeeded)) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n    let final_action_value = result.value;\n    switch (result.action_type) {\n      case ActionType.HEAL:\n        {\n          const healed = this._apply_heal(actor_state, Number(result.value));\n          final_action_value = healed;\n          this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n          break;\n        }\n      case ActionType.DEFEND:\n        {\n          this._apply_status(actor_state, new StatusEffect(action.element.name, StatusEffectType.DEFENSE, 0.0, 3));\n          this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n          break;\n        }\n      case ActionType.CAST_SPELL:\n        {\n          switch (result.spell_type) {\n            case SpellType.DAMAGE:\n              {\n                const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n                this._apply_damage(defender_state, damage);\n                final_action_value = damage;\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n                break;\n              }\n            case SpellType.BUFF:\n              {\n                this._apply_status(actor_state, new StatusEffect(action.name, StatusEffectType.BUFF, Number(result.value), 4));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n                break;\n              }\n            case SpellType.DEBUFF:\n              {\n                this._apply_status(defender_state, new StatusEffect(action.name, StatusEffectType.DEBUFF, Number(result.value), 3));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n                break;\n              }\n            default:\n              throw new Error(`Unhandled spell type: ${result.spell_type}`);\n          }\n          break;\n        }\n      case ActionType.PASS:\n        {\n          this.log_action(new ActionRecord(actor_index, ActionType.PASS, ActionTarget.SELF, `Passed`));\n          break;\n        }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type.name}`);\n    }\n    this._decay_effects(actor_index);\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach(effect => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach(buff => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach(debuff => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach(buff => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach(debuff => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n    defender.defenses().forEach(defense => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n    return Math.max(0, Math.round(damage));\n  }\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n  increment_mana() {\n    this.player_states.forEach(state => {\n      state.current_mana = Math.max(0, Math.min(25, state.current_mana + state.player.wizard.mana_per_round()));\n    });\n  }\n  action_effect_range(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_effect_range requires an action instance\");\n    }\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      if (typeof action.range !== \"function\") {\n        return [0, 0];\n      }\n      const [minVal, maxVal] = action.range();\n      const minDamage = this._calculate_damage(actorState, defenderState, action, Number(minVal));\n      const maxDamage = this._calculate_damage(actorState, defenderState, action, Number(maxVal));\n      return [Math.round(minDamage), Math.round(maxDamage)];\n    }\n    if (typeof action.range === \"function\") {\n      return action.range();\n    }\n    return [0, 0];\n  }\n  action_calculated_range(playerIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_calculated_range requires an action instance\");\n    }\n    if (action.action_type !== ActionType.CAST_SPELL || (typeof action.spell_type === \"function\" ? action.spell_type() : action.spell_type) !== SpellType.DAMAGE) {\n      if (typeof action.range === \"function\") {\n        return action.range();\n      }\n      return [0, 0];\n    }\n    const actorState = this.player_states[playerIndex];\n    const defenderState = this.player_states[1 - playerIndex];\n    const spellType = typeof action.spell_type === \"function\" ? action.spell_type() : action.spell_type;\n    if (spellType !== SpellType.DAMAGE) {\n      if (typeof action.range === \"function\") {\n        return action.range();\n      }\n      return [0, 0];\n    }\n    if (typeof action.range !== \"function\") {\n      return [0, 0];\n    }\n    const [minVal, maxVal] = action.range();\n    const minDamage = this._calculate_damage(actorState, defenderState, action, Number(minVal));\n    const maxDamage = this._calculate_damage(actorState, defenderState, action, Number(maxVal));\n    return [Math.round(minDamage), Math.round(maxDamage)];\n  }\n  action_is_redundant(actorIndex, action) {\n    var _actorState$active_ef, _enemyState$active_ef;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_is_redundant requires an action instance\");\n    }\n    if (action.action_type === ActionType.PASS) {\n      return false;\n    }\n    const actorState = this.player_states[actorIndex];\n    const activeEffects = (_actorState$active_ef = actorState.active_effects) !== null && _actorState$active_ef !== void 0 ? _actorState$active_ef : [];\n    const enemyState = this.player_states[1 - actorIndex];\n    const enemyEffects = (_enemyState$active_ef = enemyState.active_effects) !== null && _enemyState$active_ef !== void 0 ? _enemyState$active_ef : [];\n    const actionType = action.action_type;\n    if (actionType === ActionType.DEFEND) {\n      var _action$element$name, _action$element, _ref, _existing$remaining_t;\n      const effectName = (_action$element$name = (_action$element = action.element) === null || _action$element === void 0 ? void 0 : _action$element.name) !== null && _action$element$name !== void 0 ? _action$element$name : action.element;\n      if (!effectName) {\n        return false;\n      }\n      const existing = activeEffects.find(effect => (effect.effect_type === StatusEffectType.DEFENSE || effect.is_defense) && String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n      if (!existing) {\n        return false;\n      }\n      const turns = (_ref = (_existing$remaining_t = existing.remaining_turns) !== null && _existing$remaining_t !== void 0 ? _existing$remaining_t : existing.rounds_remaining) !== null && _ref !== void 0 ? _ref : 0;\n      return turns >= 2;\n    }\n    if (actionType === ActionType.HEAL) {\n      return actorState.current_health == actorState.max_health;\n    }\n    if (actionType === ActionType.CAST_SPELL) {\n      const spellType = action.spell_type;\n      if (spellType === SpellType.BUFF) {\n        var _ref2, _existing$remaining_t2;\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n        const existing = activeEffects.find(effect => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n        const turns = (_ref2 = (_existing$remaining_t2 = existing.remaining_turns) !== null && _existing$remaining_t2 !== void 0 ? _existing$remaining_t2 : existing.rounds_remaining) !== null && _ref2 !== void 0 ? _ref2 : 0;\n        return turns >= 2;\n      } else if (spellType === SpellType.DEBUFF) {\n        var _ref3, _existing$remaining_t3;\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n        const existing = enemyEffects.find(effect => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n        const turns = (_ref3 = (_existing$remaining_t3 = existing.remaining_turns) !== null && _existing$remaining_t3 !== void 0 ? _existing$remaining_t3 : existing.rounds_remaining) !== null && _ref3 !== void 0 ? _ref3 : 0;\n        return turns >= 2;\n      }\n    }\n    return false;\n  }\n  action_can_kill(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_can_kill requires an action instance\");\n    }\n    if (action.action_type === ActionType.PASS) {\n      return false;\n    }\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      const [, maxDamage] = this.action_effect_range(actorIndex, action);\n      const defenderState = this.player_states[1 - actorIndex];\n      return maxDamage >= defenderState.current_health;\n    }\n    return false;\n  }\n  player_health_level(playerIndex) {\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const enemyWizard = enemyState.player.wizard;\n    const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n    const canEnemyOneShot = enemyActions.some(action => {\n      if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n        const rangeFn = typeof action.range === \"function\" ? action.range : null;\n        const [, maxVal = 0] = rangeFn ? rangeFn.call(action) : [0, 0];\n        const damage = this._calculate_damage(enemyState, playerState, action, Number(maxVal));\n        return damage >= playerState.current_health;\n      }\n      return false;\n    });\n    if (canEnemyOneShot) {\n      return \"Extremely low\";\n    } else if (playerState.current_health <= playerState.max_health / 4) {\n      return \"Low\";\n    } else if (playerState.current_health <= playerState.max_health * (2.0 / 3.0)) {\n      return \"Medium\";\n    }\n    return \"High\";\n  }\n  player_danger_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const enemyWizard = enemyState.player.wizard;\n    const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n    const canEnemyOneShot = enemyActions.some(action => {\n      if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n        const rangeFn = typeof action.range === \"function\" ? action.range : null;\n        const [, maxVal = 0] = rangeFn ? rangeFn.call(action) : [0, 0];\n        const damage = this._calculate_damage(enemyState, playerState, action, Number(maxVal));\n        return damage >= playerState.current_health;\n      }\n      return false;\n    });\n    if (canEnemyOneShot) {\n      return \"High\";\n    }\n    if (playerState.current_health <= playerState.max_health / 2) {\n      return \"Medium\";\n    }\n    return \"Low\";\n  }\n  compact_available_action_view(playerIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    var payload = {};\n    const accuracy = action.accuracy;\n    const manaCost = action.mana_cost;\n    const effectiveness = this.action_element_effectiveness(playerIndex, action);\n    const isRedundant = this.action_is_redundant(playerIndex, action);\n    const canKill = this.action_can_kill(playerIndex, action);\n    switch (action.action_type) {\n      case ActionType.DEFEND:\n        payload = {\n          type: action.action_type.name,\n          effect: action.compact_effect(),\n          mana_cost: manaCost,\n          element_effectiveness: effectiveness,\n          is_redundant: isRedundant\n        };\n        break;\n      case ActionType.HEAL:\n        payload = {\n          type: action.action_type.name,\n          effect: action.compact_effect(),\n          mana_cost: manaCost,\n          is_redundant: isRedundant\n        };\n        break;\n      case ActionType.CAST_SPELL:\n        switch (action.spell_type) {\n          case SpellType.DAMAGE:\n            const [minDamage, maxDamage] = this.action_calculated_range(playerIndex, action);\n            payload = {\n              type: action.spell_type.name,\n              effect: `Deals ${minDamage}-${maxDamage} damage`,\n              accuracy,\n              mana_cost: manaCost,\n              element_effectiveness: effectiveness,\n              can_kill: canKill\n            };\n            break;\n          case SpellType.BUFF:\n          case SpellType.DEBUFF:\n            payload = {\n              type: action.spell_type.name,\n              effect: action.compact_effect(),\n              accuracy,\n              mana_cost: manaCost,\n              is_redundant: isRedundant\n            };\n            break;\n        }\n        break;\n      case ActionType.PASS:\n        payload = {\n          type: ActionType.PASS.name,\n          effect: action.compact_effect(),\n          mana_cost: manaCost\n        };\n        break;\n    }\n    return JSON.stringify(payload);\n  }\n  affordable_actions(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const playerState = this.player_states[playerIndex];\n    const wizard = playerState.player.wizard;\n    if (!wizard || typeof wizard.all_actions !== \"function\") {\n      return [];\n    }\n    return wizard.all_actions().filter(action => {\n      var _action$mana_cost;\n      const manaCost = typeof action.mana_cost === \"function\" ? action.mana_cost() : (_action$mana_cost = action.mana_cost) !== null && _action$mana_cost !== void 0 ? _action$mana_cost : 0;\n      return manaCost <= playerState.current_mana;\n    });\n  }\n  compact_battle_context(playerIndex) {\n    var _this$affordable_acti;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const actorState = this.player_states[playerIndex];\n    const actorWizard = actorState.player.wizard;\n    const actorInfo = {\n      health_danger_level: this.player_danger_level(playerIndex),\n      mana_level: this.player_mana_level(playerIndex),\n      offensive_level: this.player_offensive_level(playerIndex),\n      defensive_level: this.player_defensive_level(playerIndex),\n      available_actions: []\n    };\n    const availableActions = (_this$affordable_acti = this.affordable_actions(playerIndex)) !== null && _this$affordable_acti !== void 0 ? _this$affordable_acti : [];\n    actorInfo.available_actions = availableActions.map((action, _) => this.compact_available_action_view(playerIndex, action));\n    const enemyIndex = 1 - playerIndex;\n    const enemyInfo = {\n      health_danger_level: this.player_danger_level(enemyIndex),\n      mana_level: this.player_mana_level(enemyIndex),\n      offensive_level: this.player_offensive_level(enemyIndex),\n      defensive_level: this.player_defensive_level(enemyIndex)\n    };\n    return {\n      actor_info: actorInfo,\n      enemy_info: enemyInfo\n    };\n  }\n  player_mana_level(playerIndex) {\n    var _playerState$current_;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const playerState = this.player_states[playerIndex];\n    const mana = (_playerState$current_ = playerState.current_mana) !== null && _playerState$current_ !== void 0 ? _playerState$current_ : 0;\n    if (mana > 16) {\n      return \"high\";\n    }\n    if (mana > 8) {\n      return \"medium\";\n    }\n    return \"low\";\n  }\n  player_offensive_level(playerIndex) {\n    var _playerState$active_e;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const playerState = this.player_states[playerIndex];\n    const activeEffects = (_playerState$active_e = playerState.active_effects) !== null && _playerState$active_e !== void 0 ? _playerState$active_e : [];\n    const netBuffs = activeEffects.reduce((total, effect) => {\n      if (effect.effect_type === StatusEffectType.BUFF || effect.is_buff) {\n        var _effect$value;\n        return total + (Number((_effect$value = effect.value) !== null && _effect$value !== void 0 ? _effect$value : 0) || 0);\n      }\n      if (effect.effect_type === StatusEffectType.DEBUFF || effect.is_debuff) {\n        var _effect$value2;\n        return total - (Number((_effect$value2 = effect.value) !== null && _effect$value2 !== void 0 ? _effect$value2 : 0) || 0);\n      }\n      return total;\n    }, 0);\n    if (netBuffs > 0) {\n      return \"high\";\n    }\n    if (netBuffs === 0) {\n      return \"medium\";\n    }\n    return \"low\";\n  }\n  player_defensive_level(playerIndex) {\n    var _playerState$active_e2, _enemyState$player$wi, _enemyState$player$wi2;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const activeEffects = (_playerState$active_e2 = playerState.active_effects) !== null && _playerState$active_e2 !== void 0 ? _playerState$active_e2 : [];\n    const netBuffs = activeEffects.reduce((total, effect) => {\n      if (effect.effect_type === StatusEffectType.BUFF || effect.is_buff) {\n        var _effect$value3;\n        return total + (Number((_effect$value3 = effect.value) !== null && _effect$value3 !== void 0 ? _effect$value3 : 0) || 0);\n      }\n      if (effect.effect_type === StatusEffectType.DEBUFF || effect.is_debuff) {\n        var _effect$value4;\n        return total - (Number((_effect$value4 = effect.value) !== null && _effect$value4 !== void 0 ? _effect$value4 : 0) || 0);\n      }\n      return total;\n    }, 0);\n    const enemyElements = [(_enemyState$player$wi = enemyState.player.wizard.primary_element) === null || _enemyState$player$wi === void 0 ? void 0 : _enemyState$player$wi.name, (_enemyState$player$wi2 = enemyState.player.wizard.secondary_element) === null || _enemyState$player$wi2 === void 0 ? void 0 : _enemyState$player$wi2.name].filter(Boolean).map(elementName => Element.fromName(elementName));\n    const defenses = activeEffects.filter(effect => effect.effect_type === StatusEffectType.DEFENSE || effect.is_defense);\n    const shieldEffectiveness = defenses.reduce((sum, effect) => {\n      const shieldElement = Element.fromName(effect.name);\n      if (!shieldElement) {\n        return sum;\n      }\n      const elementScore = enemyElements.reduce((elementScore, enemyElement) => {\n        if (shieldElement.strengths.includes(enemyElement.name)) {\n          return elementScore + 3;\n        }\n        if (shieldElement.weaknesses.includes(enemyElement.name)) {\n          return elementScore - 1;\n        }\n        return elementScore + 1;\n      }, 0);\n      return sum + elementScore;\n    }, 0);\n    if (netBuffs > 0 && shieldEffectiveness > 0) {\n      return \"Extremely high\";\n    }\n    if (shieldEffectiveness > 0 && netBuffs === 0 || shieldEffectiveness === 0 && netBuffs > 0) {\n      return \"High\";\n    }\n    if (shieldEffectiveness < 0 && netBuffs === 0 || shieldEffectiveness === 0 && netBuffs < 0) {\n      return \"Low\";\n    }\n    if (shieldEffectiveness < 0 && netBuffs < 0) {\n      return \"Extremely low\";\n    }\n    return \"Medium\";\n  }\n  action_element_effectiveness(actorIndex, action) {\n    var _defenderState$active, _defenderState$active2;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_element_effectiveness requires an action instance\");\n    }\n    if (action.action_type === ActionType.PASS) {\n      return \"medium\";\n    }\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    const defenderWizard = defenderState.player.wizard;\n    const getElement = elementLike => {\n      if (!elementLike) {\n        return null;\n      }\n      if (typeof elementLike.name === \"string\") {\n        return Element.fromName(elementLike.name);\n      }\n      if (typeof elementLike === \"string\") {\n        return Element.fromName(elementLike);\n      }\n      return null;\n    };\n    const defenseEffects = (_defenderState$active = (_defenderState$active2 = defenderState.active_effects) === null || _defenderState$active2 === void 0 ? void 0 : _defenderState$active2.filter(effect => {\n      var _effect$effect_type;\n      return ((_effect$effect_type = effect.effect_type) !== null && _effect$effect_type !== void 0 ? _effect$effect_type : effect.type) === StatusEffectType.DEFENSE || effect.is_defense;\n    })) !== null && _defenderState$active !== void 0 ? _defenderState$active : [];\n    const defenseElements = defenseEffects.map(effect => {\n      var _effect$name;\n      return getElement((_effect$name = effect.name) !== null && _effect$name !== void 0 ? _effect$name : effect.element);\n    }).filter(Boolean);\n    if (typeof action.action_type !== \"undefined\") {\n      const actionType = action.action_type;\n      if (actionType === ActionType.CAST_SPELL) {\n        const spellType = action.spell_type;\n        if (spellType === SpellType.DAMAGE) {\n          const actionElement = getElement(action.element);\n          if (!actionElement) {\n            return \"medium\";\n          }\n          let effectivenessSum = 0;\n          defenseElements.forEach(defenseElement => {\n            if (actionElement.strengths.includes(defenseElement.name)) {\n              effectivenessSum += 1;\n            } else if (actionElement.weaknesses.includes(defenseElement.name)) {\n              effectivenessSum -= 2;\n            }\n          });\n          if (effectivenessSum > 0) {\n            return \"high\";\n          }\n          if (effectivenessSum === 0) {\n            return \"medium\";\n          }\n          return \"low\";\n        }\n      }\n      if (actionType === ActionType.DEFEND) {\n        const actionElement = getElement(action.element);\n        if (!actionElement) {\n          return \"medium\";\n        }\n        const enemyWizard = defenderWizard;\n        const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n        let effectivenessSum = 0;\n        enemyActions.forEach(enemyAction => {\n          if (enemyAction.action_type === ActionType.CAST_SPELL && enemyAction.spell_type === SpellType.DAMAGE) {\n            const enemyElement = getElement(enemyAction.element);\n            if (!enemyElement) {\n              return;\n            }\n            if (actionElement.strengths.includes(enemyElement.name)) {\n              effectivenessSum += 2;\n            } else if (actionElement.weaknesses.includes(enemyElement.name)) {\n              effectivenessSum -= 1;\n            }\n          }\n        });\n        if (effectivenessSum > 0) {\n          return \"high\";\n        }\n        if (effectivenessSum === 0) {\n          return \"medium\";\n        }\n        return \"low\";\n      }\n    }\n    return \"medium\";\n  }\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n    return lines.join(\"\\n\");\n  }\n  battleSnapshot(actingWizardIndex) {\n    var _actingState$active_e, _enemyState$active_ef2;\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n    const formatActions = (actions, use_numbers = false) => {\n      if (!(actions !== null && actions !== void 0 && actions.length)) {\n        return \"  (none)\";\n      }\n      return actions.map((action, idx) => {\n        const overview = action.overview();\n        return `${use_numbers ? idx + 1 : \"\"}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n      }).join(\"\\n\");\n    };\n    const actingActions = formatActions(actingState.player.wizard.affordable_actions(actingState.current_mana), true);\n    const enemyActions = formatActions(enemyState.player.wizard.affordable_actions(enemyState.current_mana));\n    const actingEffects = (_actingState$active_e = actingState.active_effects) !== null && _actingState$active_e !== void 0 && _actingState$active_e.length ? actingState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    const enemyEffects = (_enemyState$active_ef2 = enemyState.active_effects) !== null && _enemyState$active_ef2 !== void 0 && _enemyState$active_ef2.length ? enemyState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\nconst game_state = new GameState();\nexport { GameState };\nexport default game_state;","map":{"version":3,"names":["ActionType","ActionTarget","SpellType","StatusEffectType","EffectGroup","Player","PlayerState","StatusEffect","ActionRecord","Element","shuffle","array","randomFn","Math","random","copy","i","length","j","floor","GameState","constructor","player_states","action_log","initialize","wizard1","wizard2","assigned_order","map","wizard","index","max_hp","starting_mana","state","player","change_health","delta","id","current_health","max","min","max_health","set_health","value","change_mana","current_mana","set_mana","add_status_effect","effect","existing","active_effects","find","active","name","remaining_turns","effect_type","push","clear_expired_effects","filter","tick_effects","forEach","log_action","record","perform_action","actor_index","action","Error","actor_state","defender_state","mana_cost","result","succeeded","action_type","action_target","_decay_effects","failure_announcement","final_action_value","HEAL","healed","_apply_heal","Number","SELF","DEFEND","_apply_status","element","DEFENSE","CAST_SPELL","spell_type","DAMAGE","damage","_calculate_damage","_apply_damage","ENEMY","BUFF","DEBUFF","PASS","success_announcement","get_winner","_decrement_effects","BUFFS_AND_DEBUFFS","DEFENSES","group","updated","includes","amount","new_health","actor","defender","spell","base_damage","actor_multiplier","damage_multiplier","buffs","buff","debuffs","debuff","defender_multiplier","damage_reduction","defenses","defense","defense_element","strengths","weaknesses","round","increment_mana","mana_per_round","action_effect_range","actorIndex","actorState","defenderState","range","minVal","maxVal","minDamage","maxDamage","action_calculated_range","playerIndex","spellType","action_is_redundant","_actorState$active_ef","_enemyState$active_ef","activeEffects","enemyState","enemyEffects","actionType","_action$element$name","_action$element","_ref","_existing$remaining_t","effectName","is_defense","String","toUpperCase","turns","rounds_remaining","_ref2","_existing$remaining_t2","_ref3","_existing$remaining_t3","action_can_kill","player_health_level","playerState","enemyWizard","enemyActions","all_actions","canEnemyOneShot","some","rangeFn","call","player_danger_level","compact_available_action_view","payload","accuracy","manaCost","effectiveness","action_element_effectiveness","isRedundant","canKill","type","compact_effect","element_effectiveness","is_redundant","can_kill","JSON","stringify","affordable_actions","_action$mana_cost","compact_battle_context","_this$affordable_acti","actorWizard","actorInfo","health_danger_level","mana_level","player_mana_level","offensive_level","player_offensive_level","defensive_level","player_defensive_level","available_actions","availableActions","_","enemyIndex","enemyInfo","actor_info","enemy_info","_playerState$current_","mana","_playerState$active_e","netBuffs","reduce","total","is_buff","_effect$value","is_debuff","_effect$value2","_playerState$active_e2","_enemyState$player$wi","_enemyState$player$wi2","_effect$value3","_effect$value4","enemyElements","primary_element","secondary_element","Boolean","elementName","fromName","shieldEffectiveness","sum","shieldElement","elementScore","enemyElement","_defenderState$active","_defenderState$active2","defenderWizard","getElement","elementLike","defenseEffects","_effect$effect_type","defenseElements","_effect$name","actionElement","effectivenessSum","defenseElement","enemyAction","toString","lines","idx","actor_label","actor_id","target","join","battleSnapshot","actingWizardIndex","_actingState$active_e","_enemyState$active_ef2","actingState","formatActions","actions","use_numbers","overview","Array","isArray","actingActions","actingEffects","combat_style","game_state"],"sources":["/Users/michaelkeohane/Documents/Projects/LLM-Learnings/projects/week_2/wizard_prompt_battle/wizard-battle-client/src/classes/gameState.js"],"sourcesContent":["import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nimport Element from \"../enums/element\";\n\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\n\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(\n        new Player(index, wizard),\n        max_hp,\n        max_hp,\n        wizard.starting_mana(randomFn),\n        []\n      );\n    });\n\n    this.action_log = [];\n    return this.player_states.map((state) => state.player.wizard);\n  }\n\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, state.current_mana + delta));\n    return state.current_mana;\n  }\n\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, value));\n    return state.current_mana;\n  }\n\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter((effect) => effect.remaining_turns > 0);\n  }\n\n  tick_effects() {\n    this.player_states.forEach((state) => {\n      state.active_effects.forEach((effect) => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n\n  log_action(record) {\n    this.action_log.push(record);\n  }\n\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    const mana_cost = action.mana_cost();\n\n    if (mana_cost > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - mana_cost);\n\n    const result = action.perform_action(randomFn);\n\n    if (!result?.succeeded) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n\n    let final_action_value = result.value;\n\n    switch (result.action_type) {\n      case ActionType.HEAL: {\n        const healed = this._apply_heal(actor_state, Number(result.value));\n        final_action_value = healed;\n        this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n        break;\n      }\n      case ActionType.DEFEND: {\n        this._apply_status(\n          actor_state,\n          new StatusEffect(\n            action.element.name,\n            StatusEffectType.DEFENSE,\n            0.0,\n            3\n          )\n        );\n        this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n        break;\n      }\n      case ActionType.CAST_SPELL: {\n        switch (result.spell_type) {\n          case SpellType.DAMAGE: {\n            const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n            this._apply_damage(defender_state, damage);\n            final_action_value = damage;\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n            break;\n          }\n          case SpellType.BUFF: {\n            this._apply_status(\n              actor_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.BUFF,\n                Number(result.value),\n                4\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n            break;\n          }\n          case SpellType.DEBUFF: {\n            this._apply_status(\n              defender_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.DEBUFF,\n                Number(result.value),\n                3\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n            break;\n          }\n          default:\n            throw new Error(`Unhandled spell type: ${result.spell_type}`);\n        }\n        break;\n      }\n      case ActionType.PASS: {\n        this.log_action(new ActionRecord(actor_index, ActionType.PASS, ActionTarget.SELF, `Passed`));\n        break;\n      }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type.name}`);\n    }\n\n    this._decay_effects(actor_index);\n\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach((effect) => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach((buff) => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach((debuff) => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach((buff) => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach((debuff) => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n\n    defender.defenses().forEach((defense) => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n\n    return Math.max(0, Math.round(damage));\n  }\n\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n\n  increment_mana() {\n    this.player_states.forEach((state) => {\n      state.current_mana = Math.max(\n        0,\n        Math.min(25, state.current_mana + state.player.wizard.mana_per_round())\n      );\n    });\n  }\n\n  action_effect_range(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_effect_range requires an action instance\");\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      if (typeof action.range !== \"function\") {\n        return [0, 0];\n      }\n      const [minVal, maxVal] = action.range();\n      const minDamage = this._calculate_damage(actorState, defenderState, action, Number(minVal));\n      const maxDamage = this._calculate_damage(actorState, defenderState, action, Number(maxVal));\n      return [Math.round(minDamage), Math.round(maxDamage)];\n    }\n\n    if (typeof action.range === \"function\") {\n      return action.range();\n    }\n\n    return [0, 0];\n  }\n\n  action_calculated_range(playerIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_calculated_range requires an action instance\");\n    }\n    if (\n      action.action_type !== ActionType.CAST_SPELL ||\n      (typeof action.spell_type === \"function\" ? action.spell_type() : action.spell_type) !== SpellType.DAMAGE\n    ) {\n      if (typeof action.range === \"function\") {\n        return action.range();\n      }\n      return [0, 0];\n    }\n\n    const actorState = this.player_states[playerIndex];\n    const defenderState = this.player_states[1 - playerIndex];\n\n    const spellType = typeof action.spell_type === \"function\" ? action.spell_type() : action.spell_type;\n    if (spellType !== SpellType.DAMAGE) {\n      if (typeof action.range === \"function\") {\n        return action.range();\n      }\n      return [0, 0];\n    }\n\n    if (typeof action.range !== \"function\") {\n      return [0, 0];\n    }\n\n    const [minVal, maxVal] = action.range();\n    const minDamage = this._calculate_damage(actorState, defenderState, action, Number(minVal));\n    const maxDamage = this._calculate_damage(actorState, defenderState, action, Number(maxVal));\n    return [Math.round(minDamage), Math.round(maxDamage)];\n  }\n\n  action_is_redundant(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_is_redundant requires an action instance\");\n    }\n\n    if (action.action_type === ActionType.PASS) {\n      return false;\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const activeEffects = actorState.active_effects ?? [];\n    const enemyState = this.player_states[1 - actorIndex];\n    const enemyEffects = enemyState.active_effects ?? [];\n\n    const actionType = action.action_type;\n\n    if (actionType === ActionType.DEFEND) {\n      const effectName = action.element?.name ?? action.element;\n      if (!effectName) {\n        return false;\n      }\n\n      const existing = activeEffects.find(\n        (effect) =>\n          (effect.effect_type === StatusEffectType.DEFENSE || effect.is_defense) &&\n          String(effect.name).toUpperCase() === String(effectName).toUpperCase()\n      );\n\n      if (!existing) {\n        return false;\n      }\n\n      const turns = existing.remaining_turns ?? existing.rounds_remaining ?? 0;\n      return turns >= 2;\n    }\n\n    if (actionType === ActionType.HEAL) {\n      return actorState.current_health == actorState.max_health;\n    }\n\n    if (actionType === ActionType.CAST_SPELL) {\n      const spellType = action.spell_type;\n      if (spellType === SpellType.BUFF) {\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n\n        const existing = activeEffects.find((effect) => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n\n        const turns = existing.remaining_turns ?? existing.rounds_remaining ?? 0;\n        return turns >= 2;\n      } else if (spellType === SpellType.DEBUFF) {\n        const effectName = action.name;\n        if (!effectName) {\n          return false;\n        }\n\n        const existing = enemyEffects.find((effect) => String(effect.name).toUpperCase() === String(effectName).toUpperCase());\n        if (!existing) {\n          return false;\n        }\n\n        const turns = existing.remaining_turns ?? existing.rounds_remaining ?? 0;\n        return turns >= 2;\n      }\n    }\n\n    return false;\n  }\n\n  action_can_kill(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_can_kill requires an action instance\");\n    }\n\n    if (action.action_type === ActionType.PASS) {\n      return false;\n    }\n\n    if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n      const [, maxDamage] = this.action_effect_range(actorIndex, action);\n      const defenderState = this.player_states[1 - actorIndex];\n      return maxDamage >= defenderState.current_health;\n    }\n\n    return false;\n  }\n\n  player_health_level(playerIndex) {\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const enemyWizard = enemyState.player.wizard;\n\n    const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n\n    const canEnemyOneShot = enemyActions.some((action) => {\n      if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n        const rangeFn = typeof action.range === \"function\" ? action.range : null;\n        const [, maxVal = 0] = rangeFn ? rangeFn.call(action) : [0, 0];\n        const damage = this._calculate_damage(enemyState, playerState, action, Number(maxVal));\n        return damage >= playerState.current_health;\n      }\n      return false;\n    });\n\n    if (canEnemyOneShot) {\n      return \"Extremely low\";\n    } else if (playerState.current_health <= playerState.max_health / 4) {\n      return \"Low\";\n    } else if (playerState.current_health <= playerState.max_health * (2.0/3.0)) {\n      return \"Medium\";\n    }\n\n    return \"High\";\n  }\n\n  player_danger_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const enemyWizard = enemyState.player.wizard;\n\n    const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n\n    const canEnemyOneShot = enemyActions.some((action) => {\n      if (action.action_type === ActionType.CAST_SPELL && typeof action.spell_type === \"function\" && action.spell_type() === SpellType.DAMAGE) {\n        const rangeFn = typeof action.range === \"function\" ? action.range : null;\n        const [, maxVal = 0] = rangeFn ? rangeFn.call(action) : [0, 0];\n        const damage = this._calculate_damage(enemyState, playerState, action, Number(maxVal));\n        return damage >= playerState.current_health;\n      }\n      return false;\n    });\n\n    if (canEnemyOneShot) {\n      return \"High\";\n    }\n\n    if (playerState.current_health <= playerState.max_health / 2) {\n      return \"Medium\";\n    }\n\n    return \"Low\";\n  }\n\n  compact_available_action_view(playerIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    var payload = {};\n\n    const accuracy = action.accuracy;\n    const manaCost = action.mana_cost;\n    const effectiveness = this.action_element_effectiveness(playerIndex, action);\n    const isRedundant = this.action_is_redundant(playerIndex, action);\n    const canKill = this.action_can_kill(playerIndex, action);\n\n    switch (action.action_type) {\n      case ActionType.DEFEND:\n        payload = {\n          type: action.action_type.name,\n          effect: action.compact_effect(),\n          mana_cost: manaCost,\n          element_effectiveness: effectiveness,\n          is_redundant: isRedundant\n        };\n        break;\n      case ActionType.HEAL:\n        payload = {\n          type: action.action_type.name,\n          effect: action.compact_effect(),\n          mana_cost: manaCost,\n          is_redundant: isRedundant,\n        };\n        break;\n      case ActionType.CAST_SPELL:\n        switch (action.spell_type) {\n          case SpellType.DAMAGE:\n            const [minDamage, maxDamage] = this.action_calculated_range(playerIndex, action)\n            payload = {\n              type: action.spell_type.name,\n              effect: `Deals ${minDamage}-${maxDamage} damage`,\n              accuracy,\n              mana_cost: manaCost,\n              element_effectiveness: effectiveness,\n              can_kill: canKill,\n            };\n            break;\n          case SpellType.BUFF:\n          case SpellType.DEBUFF:\n            payload = {\n              type: action.spell_type.name,\n              effect: action.compact_effect(),\n              accuracy,\n              mana_cost: manaCost,\n              is_redundant: isRedundant,\n            };\n            break;\n        }\n        break;\n      case ActionType.PASS:\n        payload = {\n          type: ActionType.PASS.name,\n          effect: action.compact_effect(),\n          mana_cost: manaCost,\n        };\n        break;\n    }\n\n    return JSON.stringify(payload);\n  }\n\n  affordable_actions(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const playerState = this.player_states[playerIndex];\n    const wizard = playerState.player.wizard;\n\n    if (!wizard || typeof wizard.all_actions !== \"function\") {\n      return [];\n    }\n\n    return wizard\n      .all_actions()\n      .filter((action) => {\n        const manaCost = typeof action.mana_cost === \"function\" ? action.mana_cost() : action.mana_cost ?? 0;\n        return manaCost <= playerState.current_mana;\n      });\n  }\n\n  compact_battle_context(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const actorState = this.player_states[playerIndex];\n    const actorWizard = actorState.player.wizard;\n\n    const actorInfo = {\n      health_danger_level: this.player_danger_level(playerIndex),\n      mana_level: this.player_mana_level(playerIndex),\n      offensive_level: this.player_offensive_level(playerIndex),\n      defensive_level: this.player_defensive_level(playerIndex),\n      available_actions: [],\n    };\n\n    const availableActions = this.affordable_actions(playerIndex) ?? [];\n    actorInfo.available_actions = availableActions.map((action, _) => this.compact_available_action_view(playerIndex, action));\n\n    const enemyIndex = 1 - playerIndex;\n    const enemyInfo = {\n      health_danger_level: this.player_danger_level(enemyIndex),\n      mana_level: this.player_mana_level(enemyIndex),\n      offensive_level: this.player_offensive_level(enemyIndex),\n      defensive_level: this.player_defensive_level(enemyIndex),\n    };\n\n    return { actor_info: actorInfo, enemy_info: enemyInfo };\n  }\n\n  player_mana_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const playerState = this.player_states[playerIndex];\n    const mana = playerState.current_mana ?? 0;\n\n    if (mana > 16) {\n      return \"high\";\n    }\n    if (mana > 8) {\n      return \"medium\";\n    }\n    return \"low\";\n  }\n\n  player_offensive_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const playerState = this.player_states[playerIndex];\n    const activeEffects = playerState.active_effects ?? [];\n\n    const netBuffs = activeEffects.reduce((total, effect) => {\n      if (effect.effect_type === StatusEffectType.BUFF || effect.is_buff) {\n        return total + (Number(effect.value ?? 0) || 0);\n      }\n      if (effect.effect_type === StatusEffectType.DEBUFF || effect.is_debuff) {\n        return total - (Number(effect.value ?? 0) || 0);\n      }\n      return total;\n    }, 0);\n\n    if (netBuffs > 0) {\n      return \"high\";\n    }\n    if (netBuffs === 0) {\n      return \"medium\";\n    }\n    return \"low\";\n  }\n\n  player_defensive_level(playerIndex) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(playerIndex)) {\n      throw new Error(\"playerIndex must be 0 or 1\");\n    }\n\n    const playerState = this.player_states[playerIndex];\n    const enemyState = this.player_states[1 - playerIndex];\n    const activeEffects = playerState.active_effects ?? [];\n\n    const netBuffs = activeEffects.reduce((total, effect) => {\n      if (effect.effect_type === StatusEffectType.BUFF || effect.is_buff) {\n        return total + (Number(effect.value ?? 0) || 0);\n      }\n      if (effect.effect_type === StatusEffectType.DEBUFF || effect.is_debuff) {\n        return total - (Number(effect.value ?? 0) || 0);\n      }\n      return total;\n    }, 0);\n\n    const enemyElements = [enemyState.player.wizard.primary_element?.name, enemyState.player.wizard.secondary_element?.name]\n      .filter(Boolean)\n      .map((elementName) => Element.fromName(elementName));\n\n    const defenses = activeEffects.filter((effect) => effect.effect_type === StatusEffectType.DEFENSE || effect.is_defense);\n\n    const shieldEffectiveness = defenses.reduce((sum, effect) => {\n      const shieldElement = Element.fromName(effect.name);\n      if (!shieldElement) {\n        return sum;\n      }\n\n      const elementScore = enemyElements.reduce((elementScore, enemyElement) => {\n        if (shieldElement.strengths.includes(enemyElement.name)) {\n          return elementScore + 3;\n        }\n        if (shieldElement.weaknesses.includes(enemyElement.name)) {\n          return elementScore - 1;\n        }\n        return elementScore + 1;\n      }, 0);\n      return sum + elementScore;\n    }, 0);\n\n    if (netBuffs > 0 && shieldEffectiveness > 0) {\n      return \"Extremely high\";\n    }\n\n    if ((shieldEffectiveness > 0 && netBuffs === 0) || (shieldEffectiveness === 0 && netBuffs > 0)) {\n      return \"High\";\n    }\n\n    if ((shieldEffectiveness < 0 && netBuffs === 0) || (shieldEffectiveness === 0 && netBuffs < 0)) {\n      return \"Low\";\n    }\n\n    if (shieldEffectiveness < 0 && netBuffs < 0) {\n      return \"Extremely low\";\n    }\n\n    return \"Medium\";\n  }\n\n  action_element_effectiveness(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_element_effectiveness requires an action instance\");\n    }\n\n    if (action.action_type === ActionType.PASS) {\n      return \"medium\";\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    const defenderWizard = defenderState.player.wizard;\n\n    const getElement = (elementLike) => {\n      if (!elementLike) {\n        return null;\n      }\n      if (typeof elementLike.name === \"string\") {\n        return Element.fromName(elementLike.name);\n      }\n      if (typeof elementLike === \"string\") {\n        return Element.fromName(elementLike);\n      }\n      return null;\n    };\n\n    const defenseEffects = defenderState.active_effects?.filter(\n      (effect) => (effect.effect_type ?? effect.type) === StatusEffectType.DEFENSE || effect.is_defense\n    ) ?? [];\n    const defenseElements = defenseEffects\n      .map((effect) => getElement(effect.name ?? effect.element))\n      .filter(Boolean);\n\n    if (typeof action.action_type !== \"undefined\") {\n      const actionType = action.action_type;\n\n      if (actionType === ActionType.CAST_SPELL) {\n        const spellType = action.spell_type;\n        if (spellType === SpellType.DAMAGE) {\n          const actionElement = getElement(action.element);\n\n          if (!actionElement) {\n            return \"medium\";\n          }\n\n          let effectivenessSum = 0;\n          defenseElements.forEach((defenseElement) => {\n            if (actionElement.strengths.includes(defenseElement.name)) {\n              effectivenessSum += 1;\n            } else if (actionElement.weaknesses.includes(defenseElement.name)) {\n              effectivenessSum -= 2;\n            }\n          });\n\n          if (effectivenessSum > 0) {\n            return \"high\";\n          }\n          if (effectivenessSum === 0) {\n            return \"medium\";\n          }\n          return \"low\";\n        }\n      }\n\n      if (actionType === ActionType.DEFEND) {\n        const actionElement = getElement(action.element);\n        if (!actionElement) {\n          return \"medium\";\n        }\n\n        const enemyWizard = defenderWizard;\n        const enemyActions = typeof enemyWizard.all_actions === \"function\" ? enemyWizard.all_actions() : [];\n        let effectivenessSum = 0;\n\n        enemyActions.forEach((enemyAction) => {\n          if (\n            enemyAction.action_type === ActionType.CAST_SPELL &&\n            enemyAction.spell_type === SpellType.DAMAGE\n          ) {\n            const enemyElement = getElement(enemyAction.element);\n            if (!enemyElement) {\n              return;\n            }\n\n            if (actionElement.strengths.includes(enemyElement.name)) {\n              effectivenessSum += 2;\n            } else if (actionElement.weaknesses.includes(enemyElement.name)) {\n              effectivenessSum -= 1;\n            }\n          }\n        });\n\n        if (effectivenessSum > 0) {\n          return \"high\";\n        }\n        if (effectivenessSum === 0) {\n          return \"medium\";\n        }\n        return \"low\";\n      }\n    }\n\n    return \"medium\";\n  }\n\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  battleSnapshot(actingWizardIndex) {\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n\n    const formatActions = (actions, use_numbers = false) => {\n      if (!actions?.length) {\n        return \"  (none)\";\n      }\n      return actions\n        .map((action, idx) => {\n          const overview = action.overview();\n          return `${use_numbers ? idx + 1 : \"\"}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n        })\n        .join(\"\\n\");\n    };\n\n    const actingActions = formatActions(\n      actingState.player.wizard.affordable_actions(actingState.current_mana), true\n    );\n    const enemyActions = formatActions(\n      enemyState.player.wizard.affordable_actions(enemyState.current_mana)\n    );\n\n    const actingEffects = actingState.active_effects?.length\n      ? actingState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n    const enemyEffects = enemyState.active_effects?.length\n      ? enemyState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\n\nconst game_state = new GameState();\n\nexport { GameState };\nexport default game_state;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}