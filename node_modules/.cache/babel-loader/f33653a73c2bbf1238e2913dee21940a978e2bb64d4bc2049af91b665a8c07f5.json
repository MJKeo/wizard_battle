{"ast":null,"code":"import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nimport Element from \"../enums/element\";\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(new Player(index, wizard), max_hp, max_hp, wizard.starting_mana(randomFn), []);\n    });\n    this.action_log = [];\n    return this.player_states.map(state => state.player.wizard);\n  }\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, state.current_mana + delta));\n    return state.current_mana;\n  }\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, value));\n    return state.current_mana;\n  }\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter(effect => effect.remaining_turns > 0);\n  }\n  tick_effects() {\n    this.player_states.forEach(state => {\n      state.active_effects.forEach(effect => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n  log_action(record) {\n    this.action_log.push(record);\n  }\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    const mana_cost = action.mana_cost();\n    if (mana_cost > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - mana_cost);\n    const result = action.perform_action(randomFn);\n    if (!(result !== null && result !== void 0 && result.succeeded)) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n    let final_action_value = result.value;\n    switch (result.action_type) {\n      case ActionType.HEAL:\n        {\n          const healed = this._apply_heal(actor_state, Number(result.value));\n          final_action_value = healed;\n          this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n          break;\n        }\n      case ActionType.DEFEND:\n        {\n          this._apply_status(actor_state, new StatusEffect(action.element.name, StatusEffectType.DEFENSE, 0.0, 3));\n          this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n          break;\n        }\n      case ActionType.CAST_SPELL:\n        {\n          switch (result.spell_type) {\n            case SpellType.DAMAGE:\n              {\n                const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n                this._apply_damage(defender_state, damage);\n                final_action_value = damage;\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n                break;\n              }\n            case SpellType.BUFF:\n              {\n                this._apply_status(actor_state, new StatusEffect(action.name, StatusEffectType.BUFF, Number(result.value), 4));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n                break;\n              }\n            case SpellType.DEBUFF:\n              {\n                this._apply_status(defender_state, new StatusEffect(action.name, StatusEffectType.DEBUFF, Number(result.value), 3));\n                this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n                break;\n              }\n            default:\n              throw new Error(`Unhandled spell type: ${result.spell_type}`);\n          }\n          break;\n        }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type}`);\n    }\n    this._decay_effects(actor_index);\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach(effect => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find(active => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach(buff => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach(debuff => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach(buff => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach(debuff => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n    defender.defenses().forEach(defense => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n    return Math.max(0, Math.round(damage));\n  }\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n  increment_mana() {\n    this.player_states.forEach(state => {\n      state.current_mana = Math.max(0, Math.min(25, state.current_mana + state.player.wizard.mana_per_round()));\n    });\n  }\n  action_element_effectiveness(actorIndex, action) {\n    var _defenderState$active, _strongestDefenseStat;\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_element_effectiveness requires an action instance\");\n    }\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    const defenderWizard = defenderState.player.wizard;\n    const getElement = elementLike => {\n      if (!elementLike) {\n        return null;\n      }\n      if (typeof elementLike.name === \"string\") {\n        return Element.fromName(elementLike.name);\n      }\n      if (typeof elementLike === \"string\") {\n        return Element.fromName(elementLike);\n      }\n      return null;\n    };\n    const strongestDefenseStatus = (_defenderState$active = defenderState.active_effects) === null || _defenderState$active === void 0 ? void 0 : _defenderState$active.filter(effect => effect.is_defense);\n    const defenseElements = (_strongestDefenseStat = strongestDefenseStatus === null || strongestDefenseStatus === void 0 ? void 0 : strongestDefenseStatus.map(effect => Element.fromName(effect.name))) !== null && _strongestDefenseStat !== void 0 ? _strongestDefenseStat : [];\n    if (typeof action.action_type !== \"undefined\") {\n      const actionType = action.action_type;\n      if (actionType === ActionType.CAST_SPELL && typeof action.spell_type === \"function\") {\n        const spellType = action.spell_type();\n        if (spellType === SpellType.DAMAGE) {\n          const actionElement = getElement(action.element);\n          if (!actionElement) {\n            return \"medium\";\n          }\n          if (!defenseElements.length) {\n            return \"high\";\n          }\n          const hasWeakDefense = defenseElements.some(defenseElement => actionElement.weaknesses.includes(defenseElement.name));\n          if (hasWeakDefense) {\n            return \"low\";\n          }\n          const areAllStrong = defenseElements.every(defenseElement => defenseElement && defenseElement.weaknesses.includes(actionElement.name));\n          if (areAllStrong) {\n            return \"low\";\n          }\n          if (defenseElements.every(defenseElement => actionElement.strengths.includes(defenseElement.name))) {\n            return \"high\";\n          }\n          return \"medium\";\n        }\n      }\n      if (actionType === ActionType.DEFEND) {\n        var _defenderWizard$prima, _defenderWizard$secon;\n        const actionElement = getElement(action.element);\n        if (!actionElement) {\n          return \"medium\";\n        }\n        const enemyElements = [(_defenderWizard$prima = defenderWizard.primary_element) === null || _defenderWizard$prima === void 0 ? void 0 : _defenderWizard$prima.name, (_defenderWizard$secon = defenderWizard.secondary_element) === null || _defenderWizard$secon === void 0 ? void 0 : _defenderWizard$secon.name].filter(Boolean);\n        const isStrong = enemyElements.some(enemyElement => actionElement.strengths.includes(enemyElement));\n        const isWeak = enemyElements.some(enemyElement => actionElement.weaknesses.includes(enemyElement));\n        if (isStrong) {\n          return \"high\";\n        }\n        if (isWeak) {\n          return \"low\";\n        }\n        return \"medium\";\n      }\n    }\n    return \"medium\";\n  }\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n    return lines.join(\"\\n\");\n  }\n  battleSnapshot(actingWizardIndex) {\n    var _actingState$active_e, _enemyState$active_ef;\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n    const formatActions = (actions, use_numbers = false) => {\n      if (!(actions !== null && actions !== void 0 && actions.length)) {\n        return \"  (none)\";\n      }\n      return actions.map((action, idx) => {\n        const overview = action.overview();\n        return `${use_numbers ? idx + 1 : \"\"}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n      }).join(\"\\n\");\n    };\n    const actingActions = formatActions(actingState.player.wizard.affordable_actions(actingState.current_mana), true);\n    const enemyActions = formatActions(enemyState.player.wizard.affordable_actions(enemyState.current_mana));\n    const actingEffects = (_actingState$active_e = actingState.active_effects) !== null && _actingState$active_e !== void 0 && _actingState$active_e.length ? actingState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    const enemyEffects = (_enemyState$active_ef = enemyState.active_effects) !== null && _enemyState$active_ef !== void 0 && _enemyState$active_ef.length ? enemyState.active_effects.map(effect => effect.toString()).join(\", \") : \"(none)\";\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\nconst game_state = new GameState();\nexport { GameState };\nexport default game_state;","map":{"version":3,"names":["ActionType","ActionTarget","SpellType","StatusEffectType","EffectGroup","Player","PlayerState","StatusEffect","ActionRecord","Element","shuffle","array","randomFn","Math","random","copy","i","length","j","floor","GameState","constructor","player_states","action_log","initialize","wizard1","wizard2","assigned_order","map","wizard","index","max_hp","starting_mana","state","player","change_health","delta","id","current_health","max","min","max_health","set_health","value","change_mana","current_mana","set_mana","add_status_effect","effect","existing","active_effects","find","active","name","remaining_turns","effect_type","push","clear_expired_effects","filter","tick_effects","forEach","log_action","record","perform_action","actor_index","action","Error","actor_state","defender_state","mana_cost","result","succeeded","action_type","action_target","_decay_effects","failure_announcement","final_action_value","HEAL","healed","_apply_heal","Number","SELF","DEFEND","_apply_status","element","DEFENSE","CAST_SPELL","spell_type","DAMAGE","damage","_calculate_damage","_apply_damage","ENEMY","BUFF","DEBUFF","success_announcement","get_winner","_decrement_effects","BUFFS_AND_DEBUFFS","DEFENSES","group","updated","includes","amount","new_health","actor","defender","spell","base_damage","actor_multiplier","damage_multiplier","buffs","buff","debuffs","debuff","defender_multiplier","damage_reduction","defenses","defense","defense_element","strengths","weaknesses","round","increment_mana","mana_per_round","action_element_effectiveness","actorIndex","_defenderState$active","_strongestDefenseStat","actorState","defenderState","defenderWizard","getElement","elementLike","fromName","strongestDefenseStatus","is_defense","defenseElements","actionType","spellType","actionElement","hasWeakDefense","some","defenseElement","areAllStrong","every","_defenderWizard$prima","_defenderWizard$secon","enemyElements","primary_element","secondary_element","Boolean","isStrong","enemyElement","isWeak","toString","lines","idx","actor_label","actor_id","type","target","join","battleSnapshot","actingWizardIndex","_actingState$active_e","_enemyState$active_ef","actingState","enemyState","formatActions","actions","use_numbers","overview","Array","isArray","actingActions","affordable_actions","enemyActions","actingEffects","enemyEffects","combat_style","game_state"],"sources":["/Users/michaelkeohane/Documents/Projects/LLM-Learnings/projects/week_2/wizard_prompt_battle/wizard-battle-client/src/classes/gameState.js"],"sourcesContent":["import ActionType from \"../enums/actionType\";\nimport ActionTarget from \"../enums/actionTarget\";\nimport SpellType from \"../enums/spellType\";\nimport StatusEffectType from \"../enums/statusEffectType\";\nimport EffectGroup from \"../enums/effectGroup\";\nimport Player from \"./player\";\nimport PlayerState from \"./playerState\";\nimport StatusEffect from \"./statusEffect\";\nimport ActionRecord from \"./actionRecord\";\nimport Element from \"../enums/element\";\n\nconst shuffle = (array, randomFn = Math.random) => {\n  const copy = [...array];\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(randomFn() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n};\n\nclass GameState {\n  constructor() {\n    this.player_states = [];\n    this.action_log = [];\n  }\n\n  initialize(wizard1, wizard2, randomFn = Math.random) {\n    const assigned_order = shuffle([wizard1, wizard2], randomFn);\n    this.player_states = assigned_order.map((wizard, index) => {\n      const max_hp = wizard.max_hp(randomFn);\n      return new PlayerState(\n        new Player(index, wizard),\n        max_hp,\n        max_hp,\n        wizard.starting_mana(randomFn),\n        []\n      );\n    });\n\n    this.action_log = [];\n    return this.player_states.map((state) => state.player.wizard);\n  }\n\n  change_health(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, state.current_health + delta));\n    return state.current_health;\n  }\n\n  set_health(player, value) {\n    const state = this.player_states[player.id];\n    state.current_health = Math.max(0, Math.min(state.max_health, value));\n    return state.current_health;\n  }\n\n  change_mana(player, delta) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, state.current_mana + delta));\n    return state.current_mana;\n  }\n\n  set_mana(player, value) {\n    const state = this.player_states[player.id];\n    state.current_mana = Math.max(0, Math.min(25, value));\n    return state.current_mana;\n  }\n\n  add_status_effect(player, effect) {\n    const state = this.player_states[player.id];\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  clear_expired_effects(player) {\n    const state = this.player_states[player.id];\n    state.active_effects = state.active_effects.filter((effect) => effect.remaining_turns > 0);\n  }\n\n  tick_effects() {\n    this.player_states.forEach((state) => {\n      state.active_effects.forEach((effect) => {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      });\n    });\n  }\n\n  log_action(record) {\n    this.action_log.push(record);\n  }\n\n  perform_action(actor_index, action, randomFn = Math.random) {\n    if (actor_index !== 0 && actor_index !== 1) {\n      throw new Error(\"actor_index must be 0 or 1\");\n    }\n\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    const mana_cost = action.mana_cost();\n\n    if (mana_cost > actor_state.current_mana) {\n      throw new Error(\"Not enough mana to perform action\");\n    }\n\n    actor_state.current_mana = Math.max(0, actor_state.current_mana - mana_cost);\n\n    const result = action.perform_action(randomFn);\n\n    if (!result?.succeeded) {\n      this.log_action(new ActionRecord(actor_index, action.action_type, action.action_target(), \"Failed :(\"));\n      this._decay_effects(actor_index);\n      return action.failure_announcement(actor_state.player.wizard);\n    }\n\n    let final_action_value = result.value;\n\n    switch (result.action_type) {\n      case ActionType.HEAL: {\n        const healed = this._apply_heal(actor_state, Number(result.value));\n        final_action_value = healed;\n        this.log_action(new ActionRecord(actor_index, ActionType.HEAL, ActionTarget.SELF, `Healed ${healed}`));\n        break;\n      }\n      case ActionType.DEFEND: {\n        this._apply_status(\n          actor_state,\n          new StatusEffect(\n            action.element.name,\n            StatusEffectType.DEFENSE,\n            0.0,\n            3\n          )\n        );\n        this.log_action(new ActionRecord(actor_index, ActionType.DEFEND, ActionTarget.SELF, `Raised ${action.element.name} shield`));\n        break;\n      }\n      case ActionType.CAST_SPELL: {\n        switch (result.spell_type) {\n          case SpellType.DAMAGE: {\n            const damage = this._calculate_damage(actor_state, defender_state, action, Number(result.value));\n            this._apply_damage(defender_state, damage);\n            final_action_value = damage;\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Dealt ${damage}`));\n            break;\n          }\n          case SpellType.BUFF: {\n            this._apply_status(\n              actor_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.BUFF,\n                Number(result.value),\n                4\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.SELF, `Buff ${action.name}`));\n            break;\n          }\n          case SpellType.DEBUFF: {\n            this._apply_status(\n              defender_state,\n              new StatusEffect(\n                action.name,\n                StatusEffectType.DEBUFF,\n                Number(result.value),\n                3\n              )\n            );\n            this.log_action(new ActionRecord(actor_index, ActionType.CAST_SPELL, ActionTarget.ENEMY, `Debuff ${action.name}`));\n            break;\n          }\n          default:\n            throw new Error(`Unhandled spell type: ${result.spell_type}`);\n        }\n        break;\n      }\n      default:\n        throw new Error(`Unhandled action type: ${result.action_type}`);\n    }\n\n    this._decay_effects(actor_index);\n\n    return action.success_announcement(actor_state.player.wizard, final_action_value);\n  }\n\n  get_winner() {\n    if (!this.player_states.length) {\n      return null;\n    }\n    if (this.player_states[0].current_health <= 0) {\n      return this.player_states[1].player.wizard;\n    }\n    if (this.player_states[1].current_health <= 0) {\n      return this.player_states[0].player.wizard;\n    }\n    return null;\n  }\n\n  _decay_effects(actor_index) {\n    const actor_state = this.player_states[actor_index];\n    const defender_state = this.player_states[1 - actor_index];\n\n    this._decrement_effects(actor_state, EffectGroup.BUFFS_AND_DEBUFFS);\n    this._decrement_effects(defender_state, EffectGroup.DEFENSES);\n  }\n\n  _decrement_effects(state, group) {\n    const updated = [];\n    state.active_effects.forEach((effect) => {\n      if (group.includes(effect)) {\n        effect.remaining_turns = Math.max(0, effect.remaining_turns - 1);\n      }\n      if (effect.remaining_turns > 0) {\n        updated.push(effect);\n      }\n    });\n    state.active_effects = updated;\n  }\n\n  _apply_heal(state, amount) {\n    const new_health = Math.min(state.max_health, state.current_health + amount);\n    const healed = new_health - state.current_health;\n    state.current_health = new_health;\n    return healed;\n  }\n\n  _apply_status(state, effect) {\n    const existing = state.active_effects.find((active) => active.name === effect.name);\n    if (existing) {\n      existing.remaining_turns = effect.remaining_turns;\n      existing.value = effect.value;\n      existing.effect_type = effect.effect_type;\n      return;\n    }\n    state.active_effects.push(effect);\n  }\n\n  _calculate_damage(actor, defender, spell, base_damage) {\n    let actor_multiplier = actor.player.wizard.damage_multiplier();\n    actor.buffs().forEach((buff) => {\n      actor_multiplier *= 1 + buff.value;\n    });\n    actor.debuffs().forEach((debuff) => {\n      actor_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let defender_multiplier = defender.player.wizard.damage_reduction();\n    defender.buffs().forEach((buff) => {\n      defender_multiplier *= 1 + buff.value;\n    });\n    defender.debuffs().forEach((debuff) => {\n      defender_multiplier *= Math.max(0, 1 - debuff.value);\n    });\n\n    let damage = base_damage * actor_multiplier * defender_multiplier;\n\n    defender.defenses().forEach((defense) => {\n      const defense_element = defense.name;\n      if (spell.element.strengths.includes(defense_element)) {\n        damage *= 1.05;\n      } else if (spell.element.weaknesses.includes(defense_element)) {\n        damage *= 0.5;\n      } else {\n        damage *= 0.9;\n      }\n    });\n\n    return Math.max(0, Math.round(damage));\n  }\n\n  _apply_damage(state, amount) {\n    state.current_health = Math.max(0, state.current_health - amount);\n  }\n\n  increment_mana() {\n    this.player_states.forEach((state) => {\n      state.current_mana = Math.max(\n        0,\n        Math.min(25, state.current_mana + state.player.wizard.mana_per_round())\n      );\n    });\n  }\n\n  action_element_effectiveness(actorIndex, action) {\n    if (!this.player_states.length) {\n      throw new Error(\"GameState is uninitialized\");\n    }\n    if (![0, 1].includes(actorIndex)) {\n      throw new Error(\"actorIndex must be 0 or 1\");\n    }\n    if (!action || typeof action !== \"object\") {\n      throw new Error(\"action_element_effectiveness requires an action instance\");\n    }\n\n    const actorState = this.player_states[actorIndex];\n    const defenderState = this.player_states[1 - actorIndex];\n    const defenderWizard = defenderState.player.wizard;\n\n    const getElement = (elementLike) => {\n      if (!elementLike) {\n        return null;\n      }\n      if (typeof elementLike.name === \"string\") {\n        return Element.fromName(elementLike.name);\n      }\n      if (typeof elementLike === \"string\") {\n        return Element.fromName(elementLike);\n      }\n      return null;\n    };\n\n    const strongestDefenseStatus = defenderState.active_effects?.filter((effect) => effect.is_defense);\n    const defenseElements = strongestDefenseStatus?.map((effect) => Element.fromName(effect.name)) ?? [];\n\n    if (typeof action.action_type !== \"undefined\") {\n      const actionType = action.action_type;\n\n      if (actionType === ActionType.CAST_SPELL && typeof action.spell_type === \"function\") {\n        const spellType = action.spell_type();\n        if (spellType === SpellType.DAMAGE) {\n          const actionElement = getElement(action.element);\n\n          if (!actionElement) {\n            return \"medium\";\n          }\n\n          if (!defenseElements.length) {\n            return \"high\";\n          }\n\n          const hasWeakDefense = defenseElements.some((defenseElement) =>\n            actionElement.weaknesses.includes(defenseElement.name)\n          );\n          if (hasWeakDefense) {\n            return \"low\";\n          }\n\n          const areAllStrong = defenseElements.every((defenseElement) =>\n            defenseElement && defenseElement.weaknesses.includes(actionElement.name)\n          );\n          if (areAllStrong) {\n            return \"low\";\n          }\n\n          if (defenseElements.every((defenseElement) => actionElement.strengths.includes(defenseElement.name))) {\n            return \"high\";\n          }\n\n          return \"medium\";\n        }\n      }\n\n      if (actionType === ActionType.DEFEND) {\n        const actionElement = getElement(action.element);\n        if (!actionElement) {\n          return \"medium\";\n        }\n\n        const enemyElements = [defenderWizard.primary_element?.name, defenderWizard.secondary_element?.name].filter(Boolean);\n        const isStrong = enemyElements.some((enemyElement) => actionElement.strengths.includes(enemyElement));\n        const isWeak = enemyElements.some((enemyElement) => actionElement.weaknesses.includes(enemyElement));\n\n        if (isStrong) {\n          return \"high\";\n        }\n        if (isWeak) {\n          return \"low\";\n        }\n        return \"medium\";\n      }\n    }\n\n    return \"medium\";\n  }\n\n  toString() {\n    if (this.player_states.length < 2) {\n      return \"GameState: <uninitialized>\";\n    }\n\n    const lines = this.player_states.map((state, idx) => `Player ${idx + 1}: ${state.toString()}`);\n    lines.push(\"Actions:\");\n    if (!this.action_log.length) {\n      lines.push(\"  (none)\");\n    } else {\n      this.action_log.forEach((record, idx) => {\n        const actor_label = record.actor_id === 0 ? \"Player 1\" : \"Player 2\";\n        lines.push(`  ${idx + 1}. ${actor_label} -> ${record.type.name} (${record.target.name}) | ${record.result}`);\n      });\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  battleSnapshot(actingWizardIndex) {\n    if (typeof actingWizardIndex !== \"number\" || ![0, 1].includes(actingWizardIndex)) {\n      throw new Error(\"battleSnapshot requires actingWizardIndex 0 or 1\");\n    }\n\n    if (this.player_states.length < 2) {\n      throw new Error(\"GameState is not initialized\");\n    }\n\n    const actingState = this.player_states[actingWizardIndex];\n    const enemyState = this.player_states[1 - actingWizardIndex];\n\n    const formatActions = (actions, use_numbers = false) => {\n      if (!actions?.length) {\n        return \"  (none)\";\n      }\n      return actions\n        .map((action, idx) => {\n          const overview = action.overview();\n          return `${use_numbers ? idx + 1 : \"\"}- ${Array.isArray(overview) ? overview.join(\" \") : overview}`;\n        })\n        .join(\"\\n\");\n    };\n\n    const actingActions = formatActions(\n      actingState.player.wizard.affordable_actions(actingState.current_mana), true\n    );\n    const enemyActions = formatActions(\n      enemyState.player.wizard.affordable_actions(enemyState.current_mana)\n    );\n\n    const actingEffects = actingState.active_effects?.length\n      ? actingState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n    const enemyEffects = enemyState.active_effects?.length\n      ? enemyState.active_effects.map((effect) => effect.toString()).join(\", \")\n      : \"(none)\";\n\n    return `Your State:\n- Health: ${actingState.current_health}/${actingState.max_health}\n- Mana: ${actingState.current_mana}\n- Active Effects:\n    ${actingEffects}\n\nEnemy State:\n- Health: ${enemyState.current_health}/${enemyState.max_health}\n- Mana: ${enemyState.current_mana}\n- Active Effects:\n    ${enemyEffects}\n\nEnemy Available Actions:\n${enemyActions || \"  (none)\"}\n\nChoose ONE of the following actions to take:\n${actingActions || \"  (none)\"}\n\nMake sure to follow your combat style: ${actingState.player.wizard.combat_style}`;\n  }\n}\n\nconst game_state = new GameState();\n\nexport { GameState };\nexport default game_state;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}